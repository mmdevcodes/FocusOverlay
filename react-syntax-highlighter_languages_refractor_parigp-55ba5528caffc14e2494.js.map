{"version":3,"sources":["webpack:///../node_modules/refractor/lang/parigp.js"],"names":["parigp","Prism","keywords","languages","comment","string","pattern","greedy","keyword","map","split","join","RegExp","number","lookbehind","operator","punctuation","module","exports","displayName","aliases"],"mappings":"2FAYA,SAASA,EAAOC,GAUH,IACHC,EAVRD,EAAME,UAAUH,OAAS,CACvBI,QAAS,0BACTC,OAAQ,CACNC,QAAS,wBACTC,QAAQ,GAKVC,SACMN,EAAW,CAAC,aAAc,QAAS,WAAY,UAAW,SAAU,QAAS,eAAgB,SAAU,SAAU,UAAW,WAAY,UAAW,cAAe,SAAU,MAAO,QAAS,KAAM,QAAS,KAAM,OAAQ,SAAU,QAAS,SAChPA,EAAWA,EAASO,KAAI,SAAUD,GAChC,OAAOA,EAAQE,MAAM,IAAIC,KAAK,SAC7BA,KAAK,KACDC,OAAO,SAAWV,EAAW,SAEtC,SAAY,oBACZW,OAAQ,CAENP,QAAS,0GACTQ,YAAY,GAEdC,SAAU,sLACVC,YAAa,mBAlCjB,EAAQ,KAER,EAAQ,IAER,EAAQ,IAERC,EAAOC,QAAUlB,EACjBA,EAAOmB,YAAc,SACrBnB,EAAOoB,QAAU","file":"react-syntax-highlighter_languages_refractor_parigp-55ba5528caffc14e2494.js","sourcesContent":["'use strict';\n\nrequire(\"core-js/modules/es6.regexp.constructor\");\n\nrequire(\"core-js/modules/es6.regexp.split\");\n\nrequire(\"core-js/modules/es6.array.map\");\n\nmodule.exports = parigp;\nparigp.displayName = 'parigp';\nparigp.aliases = [];\n\nfunction parigp(Prism) {\n  Prism.languages.parigp = {\n    comment: /\\/\\*[\\s\\S]*?\\*\\/|\\\\\\\\.*/,\n    string: {\n      pattern: /\"(?:[^\"\\\\\\r\\n]|\\\\.)*\"/,\n      greedy: true\n    },\n    // PARI/GP does not care about white spaces at all\n    // so let's process the keywords to build an appropriate regexp\n    // (e.g. \"b *r *e *a *k\", etc.)\n    keyword: function () {\n      var keywords = ['breakpoint', 'break', 'dbg_down', 'dbg_err', 'dbg_up', 'dbg_x', 'forcomposite', 'fordiv', 'forell', 'forpart', 'forprime', 'forstep', 'forsubgroup', 'forvec', 'for', 'iferr', 'if', 'local', 'my', 'next', 'return', 'until', 'while'];\n      keywords = keywords.map(function (keyword) {\n        return keyword.split('').join(' *');\n      }).join('|');\n      return RegExp('\\\\b(?:' + keywords + ')\\\\b');\n    }(),\n    \"function\": /\\w[\\w ]*?(?= *\\()/,\n    number: {\n      // The lookbehind and the negative lookahead prevent from breaking the .. operator\n      pattern: /((?:\\. *\\. *)?)(?:\\d(?: *\\d)*(?: *(?!\\. *\\.)\\.(?: *\\d)*)?|\\. *\\d(?: *\\d)*)(?: *e *[+-]? *\\d(?: *\\d)*)?/i,\n      lookbehind: true\n    },\n    operator: /\\. *\\.|[*\\/!](?: *=)?|%(?: *=|(?: *#)?(?: *')*)?|\\+(?: *[+=])?|-(?: *[-=>])?|<(?:(?: *<)?(?: *=)?| *>)?|>(?: *>)?(?: *=)?|=(?: *=){0,2}|\\\\(?: *\\/)?(?: *=)?|&(?: *&)?|\\| *\\||['#~^]/,\n    punctuation: /[\\[\\]{}().,:;|]/\n  };\n}"],"sourceRoot":""}